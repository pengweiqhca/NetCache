<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#@ include file="../NetCache/FuncHelper.Class.tt"#>
using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace NetCache
{
    internal partial class FuncHelper
    {
<#  var parameters = new Dictionary<string, string>
    {
        { "key", "1" },
        { "typeof(TimeSpan)", "2" },
        { "typeof(CancellationToken)", "3" },
    };
    var parameterTypes = parameters.Keys.ToArray();
    var funcs = Enumerable.Range(1, parameterTypes.Length)
        .SelectMany(index => PermutationAndCombination<string>.GetPermutation(parameterTypes, index))
        .Union(new [] { Array.Empty<string>() })
        .OrderBy(types => types.Length)
        .ThenBy(types =>
        {
            var order = 0;

            foreach (var type in types)
                for (var index = 0; index < parameterTypes.Length; index++)
                {
                    if (parameterTypes[index] == type)
                    {
                        order = order * 10 + index;

                        continue;
                    }
                }

            return order;
        })
        .ToArray(); #>
        private Type CreateType(ModuleBuilder module)
        {
            var proxy = module.GetType("NetCache.FuncAdapter@");
            if (proxy != null) throw new InvalidOperationException("TYpe 'NetCache.FuncAdapter@' has exits.");

            var adapter = module.DefineType("NetCache.FuncAdapter@", TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.Public | TypeAttributes.Sealed, typeof(object));

            var gp = adapter.DefineGenericParameters("TK", "TV");

            var func = adapter.DefineField("_func", typeof(object), FieldAttributes.Private);

            var ctor = adapter.DefineConstructor(MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName, CallingConventions.Standard, new[] { typeof(object) });

            ctor.DefineParameter(1, ParameterAttributes.None, "func");

            var il = ctor.GetILGenerator();

            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Call, typeof(object).GetConstructors().First());
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldarg_1);
            il.Emit(OpCodes.Stfld, func);
            il.Emit(OpCodes.Ret);

            MethodBuilder am;
            var key = gp[0].UnderlyingSystemType;

            var aggressiveInlining = new CustomAttributeBuilder(typeof(MethodImplAttribute).GetConstructor(new[] { typeof(MethodImplOptions) }), new object[] { MethodImplOptions.AggressiveInlining });

            var taskReturnType = typeof(Task<>).MakeGenericType(gp[1].UnderlyingSystemType);
            var valueTaskReturnType = typeof(ValueTask<>).MakeGenericType(gp[1].UnderlyingSystemType);

            var syncCtor = typeof(ValueTask<>).GetConstructors().First(c => !c.GetParameters()[0].ParameterType.Name.Contains("Task`1"));
            var asyncCtor = typeof(ValueTask<>).GetConstructors().First(c => c.GetParameters()[0].ParameterType.Name.Contains("Task`1"));

            var invoke0 = typeof(Func<>).GetMethod("Invoke");
            var invoke1 = typeof(Func<,>).GetMethod("Invoke");
            var invoke2 = typeof(Func<,,>).GetMethod("Invoke");
            var invoke3 = typeof(Func<,,,>).GetMethod("Invoke");

<#  for (var j = 0; j < 4; j++)
    for (var index = 0; index < funcs.Length; index++)
    { #>
            am = adapter.DefineMethod("Wrap<#= index + funcs.Length * j #>", MethodAttributes.Public | MethodAttributes.HideBySig, <#= j < 1 ? "gp[1].UnderlyingSystemType" : "valueTaskReturnType" #>, new [] { key, typeof(TimeSpan), typeof(CancellationToken) });

            am.DefineParameter(1, ParameterAttributes.None, "key");
            am.DefineParameter(2, ParameterAttributes.None, "expiry");
            am.DefineParameter(3, ParameterAttributes.None, "cancellationToken");

            am.SetCustomAttribute(aggressiveInlining);

            il = am.GetILGenerator();

            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldfld, func);
            il.Emit(OpCodes.Castclass, typeof(Func<<#= new String(',', funcs[index].Length) #>>).MakeGenericType(<#= string.Join(", ", funcs[index].Union(new [] { j < 2 ? "gp[1].UnderlyingSystemType" : (j < 3 ? "taskReturnType" : "valueTaskReturnType") })) #>));
<# foreach (var p in funcs[index])
{ #>
            il.Emit(OpCodes.Ldarg_<#= parameters[p] #>);
<# } #>
            il.Emit(OpCodes.Callvirt, invoke<#= funcs[index].Length #>);
<# if (j == 1)
{ #>
            il.Emit(OpCodes.Newobj, syncCtor);
<# }
else if (j == 2)
{ #>
            il.Emit(OpCodes.Newobj, asyncCtor);
<# } #>
            il.Emit(OpCodes.Ret);

<# if (j == 0)
{ #>
            _wrapMethods[new FuncType
<# }
else
{ #>
            _wrapAsyncMethods[new FuncType
<# } #>
            {
<#  for (var i = 1; i <= funcs[index].Length; i++)
    { #>
                Arg<#= i #> = <#= funcs[index][i - 1] == "key" ? "typeof(object)" : funcs[index][i - 1] #>,
<# } #>
<# if (j == 2)
{ #>
                ReturnArg = typeof(Task<>),
<# }
else if (j == 3)
{ #>
                ReturnArg = typeof(ValueTask<>),
<# } #>
            }] = <#= index + funcs.Length * j #>;

<# } #>
#if NETSTANDARD2_0
            return adapter.CreateTypeInfo()!;
#else
            return adapter.CreateType()!;
#endif
        }
    }
}
