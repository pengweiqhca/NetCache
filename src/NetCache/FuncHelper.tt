<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#@ include file="FuncHelper.Class.tt"#>
using System;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace NetCache
{
<#  var parameters = new Dictionary<string, string>
    {
        { "TK", "key" },
        { "TimeSpan", "expiry" },
        { "CancellationToken", "cancellationToken" },
    };
    var parameterTypes = parameters.Keys.ToArray();
    var funcs = Enumerable.Range(1, parameterTypes.Length)
        .SelectMany(index => PermutationAndCombination<string>.GetPermutation(parameterTypes, index))
        .Union(new [] { Array.Empty<string>() })
        .OrderBy(types => types.Length)
        .ThenBy(types =>
        {
            var order = 0;

            foreach (var type in types)
                for (var index = 0; index < parameterTypes.Length; index++)
                {
                    if (parameterTypes[index] == type)
                    {
                        order = order * 10 + index;

                        continue;
                    }
                }

            return order;
        })
        .ToArray(); #>
    internal static partial class FuncHelper
    {
        #region Sync Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Func<<#= string.Join(", ", parameterTypes) #>, TV> Wrap<TK, TV>(Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>TV> func) =>
            new Adapter<TK, TV>(func).Wrap<#= index + funcs.Length * 0 #>;

<#  } #>
        #endregion

        #region Async Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Func<<#= string.Join(", ", parameterTypes) #>, ValueTask<TV>> WrapAsync<TK, TV>(Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>TV> func) =>
            new Adapter<TK, TV>(func).Wrap<#= index + funcs.Length * 1 #>;

<#  } #>
        #endregion

        #region Task Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Func<<#= string.Join(", ", parameterTypes) #>, ValueTask<TV>> WrapAsync<TK, TV>(Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>Task<TV>> func) =>
            new Adapter<TK, TV>(func).Wrap<#= index + funcs.Length * 2 #>;

<#  } #>
        #endregion

        #region ValueTask Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Func<<#= string.Join(", ", parameterTypes) #>, ValueTask<TV>> WrapAsync<TK, TV>(Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>ValueTask<TV>> func) =>
            new Adapter<TK, TV>(func).Wrap<#= index + funcs.Length * 3 #>;

<#  } #>
        #endregion

        private class Adapter<TK, TV>
        {
            private object _func;

            public Adapter(object func) => _func = func;

            #region Sync Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public TV Wrap<#= index + funcs.Length * 0 #>(<#= string.Join(", ", parameters.Select(kv => kv.Key + " " + kv.Value)) #>) =>
                ((Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>TV>)_func)(<#= string.Join(", ", funcs[index].Select(p => parameters[p])) #>);

<#  } #>
            #endregion

            #region Async Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public ValueTask<TV> Wrap<#= index + funcs.Length * 1 #>(<#= string.Join(", ", parameters.Select(kv => kv.Key + " " + kv.Value)) #>) =>
                new ValueTask<TV>(((Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>TV>)_func)(<#= string.Join(", ", funcs[index].Select(p => parameters[p])) #>));

<#  } #>
            #endregion

            #region Task Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public ValueTask<TV> Wrap<#= index + funcs.Length *  2 #>(<#= string.Join(", ", parameters.Select(kv => kv.Key + " " + kv.Value)) #>) =>
                new ValueTask<TV>(((Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>Task<TV>>)_func)(<#= string.Join(", ", funcs[index].Select(p => parameters[p])) #>));

<#  } #>
            #endregion

            #region ValueTask Wrap

<#  for (var index = 0; index < funcs.Length; index++)
    { #>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public ValueTask<TV> Wrap<#= index + funcs.Length * 3 #>(<#= string.Join(", ", parameters.Select(kv => kv.Key + " " + kv.Value)) #>) =>
                ((Func<<#= string.Join(", ", funcs[index].Length > 0 ? funcs[index].Union(new [] { "" }) : funcs[index]) #>ValueTask<TV>>)_func)(<#= string.Join(", ", funcs[index].Select(p => parameters[p])) #>);

<#  } #>
            #endregion
        }
    }
}
